/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Task Management API
 * FastAPI + React Todo App
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { client } from './client';
export type ValidationErrorCtx = { [key: string]: unknown };

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
  input?: unknown;
  ctx?: ValidationErrorCtx;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * „ÇΩ„Éº„ÉàÈ†Ü
 */
export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


export const SortOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ‰ΩúÊàêÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface StatusCreate {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  /** @maxLength 7 */
  color: string;
}

/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ„É¨„Çπ„Éù„É≥„ÇπÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface StatusResponse {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  /** @maxLength 7 */
  color: string;
  id: number;
  order: number;
  created_at: string;
  updated_at: string;
}

/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ‰∏ÄË¶ß„É¨„Çπ„Éù„É≥„ÇπÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface StatusListResponse {
  statuses: StatusResponse[];
}

/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ‰∏¶„Å≥Êõø„ÅàÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface StatusReorder {
  /**
   * ‰∏¶„Å≥È†Ü„ÅÆ„Çπ„ÉÜ„Éº„Çø„ÇπID„É™„Çπ„Éà
   * @minItems 1
   */
  order: number[];
}

/**
 * „Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞Áî®„Çπ„Ç≠„Éº„Éû
 */
export interface StatusUpdate {
  /**
   * @minLength 1
   * @maxLength 50
   */
  name: string;
  /** @maxLength 7 */
  color: string;
}

/**
 * „Çø„Çπ„ÇØ‰ΩúÊàêÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface TaskCreate {
  /**
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  content: string;
  due_date: string;
  status_id: number;
}

/**
 * „Çø„Çπ„ÇØ„É¨„Çπ„Éù„É≥„ÇπÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface TaskResponse {
  /**
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  content: string;
  due_date: string;
  status_id: number;
  id: number;
  created_at: string;
  updated_at: string;
}

/**
 * „Çø„Çπ„ÇØ‰∏ÄË¶ß„É¨„Çπ„Éù„É≥„ÇπÁî®„Çπ„Ç≠„Éº„Éû
 */
export interface TaskListResponse {
  tasks: TaskResponse[];
}

/**
 * „Çø„Çπ„ÇØÊõ¥Êñ∞Áî®„Çπ„Ç≠„Éº„Éû
 */
export interface TaskUpdate {
  /**
   * @minLength 1
   * @maxLength 255
   */
  title: string;
  content: string;
  due_date: string;
  status_id: number;
}

export type ListTasksTasksGetParams = {
order?: SortOrder;
};

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ‰∏ÄË¶ßÂèñÂæóÔºàorderÈ†ÜÔºâ
 * @summary List Statuses
 */
export const getListStatusesStatusesGetUrl = () => {


  

  return `/statuses`
}

export const listStatusesStatusesGet = async ( options?: RequestInit): Promise<StatusListResponse> => {
  
  return client<StatusListResponse>(getListStatusesStatusesGetUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListStatusesStatusesGetQueryKey = () => {
    return [
    `/statuses`
    ] as const;
    }

    
export const getListStatusesStatusesGetQueryOptions = <TData = Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListStatusesStatusesGetQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listStatusesStatusesGet>>> = ({ signal }) => listStatusesStatusesGet({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListStatusesStatusesGetQueryResult = NonNullable<Awaited<ReturnType<typeof listStatusesStatusesGet>>>
export type ListStatusesStatusesGetQueryError = unknown


export function useListStatusesStatusesGet<TData = Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listStatusesStatusesGet>>,
          TError,
          Awaited<ReturnType<typeof listStatusesStatusesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListStatusesStatusesGet<TData = Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listStatusesStatusesGet>>,
          TError,
          Awaited<ReturnType<typeof listStatusesStatusesGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListStatusesStatusesGet<TData = Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Statuses
 */

export function useListStatusesStatusesGet<TData = Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listStatusesStatusesGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListStatusesStatusesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ‰ΩúÊàê
 * @summary Create Status
 */
export const getCreateStatusStatusesPostUrl = () => {


  

  return `/statuses`
}

export const createStatusStatusesPost = async (statusCreate: StatusCreate, options?: RequestInit): Promise<StatusResponse> => {
  
  return client<StatusResponse>(getCreateStatusStatusesPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      statusCreate,)
  }
);}




export const getCreateStatusStatusesPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStatusStatusesPost>>, TError,{data: StatusCreate}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof createStatusStatusesPost>>, TError,{data: StatusCreate}, TContext> => {

const mutationKey = ['createStatusStatusesPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createStatusStatusesPost>>, {data: StatusCreate}> = (props) => {
          const {data} = props ?? {};

          return  createStatusStatusesPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateStatusStatusesPostMutationResult = NonNullable<Awaited<ReturnType<typeof createStatusStatusesPost>>>
    export type CreateStatusStatusesPostMutationBody = StatusCreate
    export type CreateStatusStatusesPostMutationError = HTTPValidationError

    /**
 * @summary Create Status
 */
export const useCreateStatusStatusesPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createStatusStatusesPost>>, TError,{data: StatusCreate}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createStatusStatusesPost>>,
        TError,
        {data: StatusCreate},
        TContext
      > => {
      return useMutation(getCreateStatusStatusesPostMutationOptions(options), queryClient);
    }
    
/**
 * „Çπ„ÉÜ„Éº„Çø„ÇπË©≥Á¥∞ÂèñÂæó
 * @summary Get Status
 */
export const getGetStatusStatusesStatusIdGetUrl = (statusId: number,) => {


  

  return `/statuses/${statusId}`
}

export const getStatusStatusesStatusIdGet = async (statusId: number, options?: RequestInit): Promise<StatusResponse> => {
  
  return client<StatusResponse>(getGetStatusStatusesStatusIdGetUrl(statusId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetStatusStatusesStatusIdGetQueryKey = (statusId: number,) => {
    return [
    `/statuses/${statusId}`
    ] as const;
    }

    
export const getGetStatusStatusesStatusIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError = HTTPValidationError>(statusId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetStatusStatusesStatusIdGetQueryKey(statusId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>> = ({ signal }) => getStatusStatusesStatusIdGet(statusId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(statusId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetStatusStatusesStatusIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>>
export type GetStatusStatusesStatusIdGetQueryError = HTTPValidationError


export function useGetStatusStatusesStatusIdGet<TData = Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError = HTTPValidationError>(
 statusId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>,
          TError,
          Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatusStatusesStatusIdGet<TData = Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError = HTTPValidationError>(
 statusId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>,
          TError,
          Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetStatusStatusesStatusIdGet<TData = Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError = HTTPValidationError>(
 statusId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Status
 */

export function useGetStatusStatusesStatusIdGet<TData = Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError = HTTPValidationError>(
 statusId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getStatusStatusesStatusIdGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetStatusStatusesStatusIdGetQueryOptions(statusId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * „Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞
 * @summary Update Status
 */
export const getUpdateStatusStatusesStatusIdPutUrl = (statusId: number,) => {


  

  return `/statuses/${statusId}`
}

export const updateStatusStatusesStatusIdPut = async (statusId: number,
    statusUpdate: StatusUpdate, options?: RequestInit): Promise<StatusResponse> => {
  
  return client<StatusResponse>(getUpdateStatusStatusesStatusIdPutUrl(statusId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      statusUpdate,)
  }
);}




export const getUpdateStatusStatusesStatusIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStatusStatusesStatusIdPut>>, TError,{statusId: number;data: StatusUpdate}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof updateStatusStatusesStatusIdPut>>, TError,{statusId: number;data: StatusUpdate}, TContext> => {

const mutationKey = ['updateStatusStatusesStatusIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateStatusStatusesStatusIdPut>>, {statusId: number;data: StatusUpdate}> = (props) => {
          const {statusId,data} = props ?? {};

          return  updateStatusStatusesStatusIdPut(statusId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateStatusStatusesStatusIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateStatusStatusesStatusIdPut>>>
    export type UpdateStatusStatusesStatusIdPutMutationBody = StatusUpdate
    export type UpdateStatusStatusesStatusIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Status
 */
export const useUpdateStatusStatusesStatusIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateStatusStatusesStatusIdPut>>, TError,{statusId: number;data: StatusUpdate}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateStatusStatusesStatusIdPut>>,
        TError,
        {statusId: number;data: StatusUpdate},
        TContext
      > => {
      return useMutation(getUpdateStatusStatusesStatusIdPutMutationOptions(options), queryClient);
    }
    
/**
 * „Çπ„ÉÜ„Éº„Çø„ÇπÂâäÈô§
 * @summary Delete Status
 */
export const getDeleteStatusStatusesStatusIdDeleteUrl = (statusId: number,) => {


  

  return `/statuses/${statusId}`
}

export const deleteStatusStatusesStatusIdDelete = async (statusId: number, options?: RequestInit): Promise<void> => {
  
  return client<void>(getDeleteStatusStatusesStatusIdDeleteUrl(statusId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteStatusStatusesStatusIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStatusStatusesStatusIdDelete>>, TError,{statusId: number}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteStatusStatusesStatusIdDelete>>, TError,{statusId: number}, TContext> => {

const mutationKey = ['deleteStatusStatusesStatusIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteStatusStatusesStatusIdDelete>>, {statusId: number}> = (props) => {
          const {statusId} = props ?? {};

          return  deleteStatusStatusesStatusIdDelete(statusId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteStatusStatusesStatusIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteStatusStatusesStatusIdDelete>>>
    
    export type DeleteStatusStatusesStatusIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Status
 */
export const useDeleteStatusStatusesStatusIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteStatusStatusesStatusIdDelete>>, TError,{statusId: number}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteStatusStatusesStatusIdDelete>>,
        TError,
        {statusId: number},
        TContext
      > => {
      return useMutation(getDeleteStatusStatusesStatusIdDeleteMutationOptions(options), queryClient);
    }
    
/**
 * „Çπ„ÉÜ„Éº„Çø„Çπ‰∏¶„Å≥Êõø„Åà
 * @summary Reorder Statuses
 */
export const getReorderStatusesStatusesReorderPutUrl = () => {


  

  return `/statuses/reorder`
}

export const reorderStatusesStatusesReorderPut = async (statusReorder: StatusReorder, options?: RequestInit): Promise<StatusListResponse> => {
  
  return client<StatusListResponse>(getReorderStatusesStatusesReorderPutUrl(),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      statusReorder,)
  }
);}




export const getReorderStatusesStatusesReorderPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderStatusesStatusesReorderPut>>, TError,{data: StatusReorder}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof reorderStatusesStatusesReorderPut>>, TError,{data: StatusReorder}, TContext> => {

const mutationKey = ['reorderStatusesStatusesReorderPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof reorderStatusesStatusesReorderPut>>, {data: StatusReorder}> = (props) => {
          const {data} = props ?? {};

          return  reorderStatusesStatusesReorderPut(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type ReorderStatusesStatusesReorderPutMutationResult = NonNullable<Awaited<ReturnType<typeof reorderStatusesStatusesReorderPut>>>
    export type ReorderStatusesStatusesReorderPutMutationBody = StatusReorder
    export type ReorderStatusesStatusesReorderPutMutationError = HTTPValidationError

    /**
 * @summary Reorder Statuses
 */
export const useReorderStatusesStatusesReorderPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof reorderStatusesStatusesReorderPut>>, TError,{data: StatusReorder}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof reorderStatusesStatusesReorderPut>>,
        TError,
        {data: StatusReorder},
        TContext
      > => {
      return useMutation(getReorderStatusesStatusesReorderPutMutationOptions(options), queryClient);
    }
    
/**
 * „Çø„Çπ„ÇØ‰∏ÄË¶ßÂèñÂæóÔºàÁ∑†ÂàáÊó•„Åß„ÇΩ„Éº„ÉàÔºâ
 * @summary List Tasks
 */
export const getListTasksTasksGetUrl = (params?: ListTasksTasksGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/tasks?${stringifiedParams}` : `/tasks`
}

export const listTasksTasksGet = async (params?: ListTasksTasksGetParams, options?: RequestInit): Promise<TaskListResponse> => {
  
  return client<TaskListResponse>(getListTasksTasksGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getListTasksTasksGetQueryKey = (params?: ListTasksTasksGetParams,) => {
    return [
    `/tasks`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getListTasksTasksGetQueryOptions = <TData = Awaited<ReturnType<typeof listTasksTasksGet>>, TError = HTTPValidationError>(params?: ListTasksTasksGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasksTasksGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTasksTasksGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTasksTasksGet>>> = ({ signal }) => listTasksTasksGet(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTasksTasksGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTasksTasksGetQueryResult = NonNullable<Awaited<ReturnType<typeof listTasksTasksGet>>>
export type ListTasksTasksGetQueryError = HTTPValidationError


export function useListTasksTasksGet<TData = Awaited<ReturnType<typeof listTasksTasksGet>>, TError = HTTPValidationError>(
 params: undefined |  ListTasksTasksGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasksTasksGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasksTasksGet>>,
          TError,
          Awaited<ReturnType<typeof listTasksTasksGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTasksTasksGet<TData = Awaited<ReturnType<typeof listTasksTasksGet>>, TError = HTTPValidationError>(
 params?: ListTasksTasksGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasksTasksGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasksTasksGet>>,
          TError,
          Awaited<ReturnType<typeof listTasksTasksGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTasksTasksGet<TData = Awaited<ReturnType<typeof listTasksTasksGet>>, TError = HTTPValidationError>(
 params?: ListTasksTasksGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasksTasksGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Tasks
 */

export function useListTasksTasksGet<TData = Awaited<ReturnType<typeof listTasksTasksGet>>, TError = HTTPValidationError>(
 params?: ListTasksTasksGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasksTasksGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTasksTasksGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * „Çø„Çπ„ÇØ‰ΩúÊàê
 * @summary Create Task
 */
export const getCreateTaskTasksPostUrl = () => {


  

  return `/tasks`
}

export const createTaskTasksPost = async (taskCreate: TaskCreate, options?: RequestInit): Promise<TaskResponse> => {
  
  return client<TaskResponse>(getCreateTaskTasksPostUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      taskCreate,)
  }
);}




export const getCreateTaskTasksPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTaskTasksPost>>, TError,{data: TaskCreate}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof createTaskTasksPost>>, TError,{data: TaskCreate}, TContext> => {

const mutationKey = ['createTaskTasksPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTaskTasksPost>>, {data: TaskCreate}> = (props) => {
          const {data} = props ?? {};

          return  createTaskTasksPost(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTaskTasksPostMutationResult = NonNullable<Awaited<ReturnType<typeof createTaskTasksPost>>>
    export type CreateTaskTasksPostMutationBody = TaskCreate
    export type CreateTaskTasksPostMutationError = HTTPValidationError

    /**
 * @summary Create Task
 */
export const useCreateTaskTasksPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTaskTasksPost>>, TError,{data: TaskCreate}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTaskTasksPost>>,
        TError,
        {data: TaskCreate},
        TContext
      > => {
      return useMutation(getCreateTaskTasksPostMutationOptions(options), queryClient);
    }
    
/**
 * „Çø„Çπ„ÇØË©≥Á¥∞ÂèñÂæó
 * @summary Get Task
 */
export const getGetTaskTasksTaskIdGetUrl = (taskId: number,) => {


  

  return `/tasks/${taskId}`
}

export const getTaskTasksTaskIdGet = async (taskId: number, options?: RequestInit): Promise<TaskResponse> => {
  
  return client<TaskResponse>(getGetTaskTasksTaskIdGetUrl(taskId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getGetTaskTasksTaskIdGetQueryKey = (taskId: number,) => {
    return [
    `/tasks/${taskId}`
    ] as const;
    }

    
export const getGetTaskTasksTaskIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError = HTTPValidationError>(taskId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTaskTasksTaskIdGetQueryKey(taskId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>> = ({ signal }) => getTaskTasksTaskIdGet(taskId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(taskId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTaskTasksTaskIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>>
export type GetTaskTasksTaskIdGetQueryError = HTTPValidationError


export function useGetTaskTasksTaskIdGet<TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError = HTTPValidationError>(
 taskId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTaskTasksTaskIdGet<TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError = HTTPValidationError>(
 taskId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>,
          TError,
          Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTaskTasksTaskIdGet<TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError = HTTPValidationError>(
 taskId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Task
 */

export function useGetTaskTasksTaskIdGet<TData = Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError = HTTPValidationError>(
 taskId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTaskTasksTaskIdGet>>, TError, TData>>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTaskTasksTaskIdGetQueryOptions(taskId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}





/**
 * „Çø„Çπ„ÇØÊõ¥Êñ∞
 * @summary Update Task
 */
export const getUpdateTaskTasksTaskIdPutUrl = (taskId: number,) => {


  

  return `/tasks/${taskId}`
}

export const updateTaskTasksTaskIdPut = async (taskId: number,
    taskUpdate: TaskUpdate, options?: RequestInit): Promise<TaskResponse> => {
  
  return client<TaskResponse>(getUpdateTaskTasksTaskIdPutUrl(taskId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      taskUpdate,)
  }
);}




export const getUpdateTaskTasksTaskIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTaskTasksTaskIdPut>>, TError,{taskId: number;data: TaskUpdate}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof updateTaskTasksTaskIdPut>>, TError,{taskId: number;data: TaskUpdate}, TContext> => {

const mutationKey = ['updateTaskTasksTaskIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTaskTasksTaskIdPut>>, {taskId: number;data: TaskUpdate}> = (props) => {
          const {taskId,data} = props ?? {};

          return  updateTaskTasksTaskIdPut(taskId,data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTaskTasksTaskIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateTaskTasksTaskIdPut>>>
    export type UpdateTaskTasksTaskIdPutMutationBody = TaskUpdate
    export type UpdateTaskTasksTaskIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Task
 */
export const useUpdateTaskTasksTaskIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTaskTasksTaskIdPut>>, TError,{taskId: number;data: TaskUpdate}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTaskTasksTaskIdPut>>,
        TError,
        {taskId: number;data: TaskUpdate},
        TContext
      > => {
      return useMutation(getUpdateTaskTasksTaskIdPutMutationOptions(options), queryClient);
    }
    
/**
 * „Çø„Çπ„ÇØÂâäÈô§
 * @summary Delete Task
 */
export const getDeleteTaskTasksTaskIdDeleteUrl = (taskId: number,) => {


  

  return `/tasks/${taskId}`
}

export const deleteTaskTasksTaskIdDelete = async (taskId: number, options?: RequestInit): Promise<void> => {
  
  return client<void>(getDeleteTaskTasksTaskIdDeleteUrl(taskId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getDeleteTaskTasksTaskIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTaskTasksTaskIdDelete>>, TError,{taskId: number}, TContext>, request?: SecondParameter<typeof client>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTaskTasksTaskIdDelete>>, TError,{taskId: number}, TContext> => {

const mutationKey = ['deleteTaskTasksTaskIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTaskTasksTaskIdDelete>>, {taskId: number}> = (props) => {
          const {taskId} = props ?? {};

          return  deleteTaskTasksTaskIdDelete(taskId,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTaskTasksTaskIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTaskTasksTaskIdDelete>>>
    
    export type DeleteTaskTasksTaskIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Task
 */
export const useDeleteTaskTasksTaskIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTaskTasksTaskIdDelete>>, TError,{taskId: number}, TContext>, request?: SecondParameter<typeof client>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTaskTasksTaskIdDelete>>,
        TError,
        {taskId: number},
        TContext
      > => {
      return useMutation(getDeleteTaskTasksTaskIdDeleteMutationOptions(options), queryClient);
    }
